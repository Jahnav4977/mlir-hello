./build/bin/mx-opt --mlir-print-ir-after-all ./test/Mx/reshapetest2.mlir 2> ./test/IR_Dump/reshapetest2.txt

// -----// IR Dump After {anonymous}::MxToTosaLowerPass () //----- //
module {
  func.func @test_reshape(%arg0: tensor<2x3xf32>) -> tensor<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %0 = tosa.reshape %arg0 {new_shape = array<i64: 1, 2, 3>} : (tensor<2x3xf32>) -> tensor<1x2x3xf32>
    return %0 : tensor<1x2x3xf32>
  }
}


// -----// IR Dump After TosaToTensor (tosa-to-tensor) //----- //
module {
  func.func @test_reshape(%arg0: tensor<2x3xf32>) -> tensor<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %expanded = tensor.expand_shape %arg0 [[0, 1], [2]] output_shape [1, 2, 3] : tensor<2x3xf32> into tensor<1x2x3xf32>
    return %expanded : tensor<1x2x3xf32>
  }
}


// -----// IR Dump After TosaToLinalgNamed (tosa-to-linalg-named) //----- //
func.func @test_reshape(%arg0: tensor<2x3xf32>) -> tensor<1x2x3xf32> attributes {llvm.emit_c_interface} {
  %expanded = tensor.expand_shape %arg0 [[0, 1], [2]] output_shape [1, 2, 3] : tensor<2x3xf32> into tensor<1x2x3xf32>
  return %expanded : tensor<1x2x3xf32>
}

// -----// IR Dump After TosaToLinalg (tosa-to-linalg) //----- //
func.func @test_reshape(%arg0: tensor<2x3xf32>) -> tensor<1x2x3xf32> attributes {llvm.emit_c_interface} {
  %expanded = tensor.expand_shape %arg0 [[0, 1], [2]] output_shape [1, 2, 3] : tensor<2x3xf32> into tensor<1x2x3xf32>
  return %expanded : tensor<1x2x3xf32>
}

// -----// IR Dump After OneShotBufferize (one-shot-bufferize) //----- //
module {
  func.func @test_reshape(%arg0: tensor<2x3xf32>) -> tensor<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %0 = bufferization.to_memref %arg0 : memref<2x3xf32, strided<[?, ?], offset: ?>>
    %expand_shape = memref.expand_shape %0 [[0, 1], [2]] output_shape [1, 2, 3] : memref<2x3xf32, strided<[?, ?], offset: ?>> into memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
    memref.copy %expand_shape, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
    %1 = bufferization.to_tensor %alloc : memref<1x2x3xf32>
    return %1 : tensor<1x2x3xf32>
  }
}


// -----// IR Dump After FuncBufferize (func-bufferize) //----- //
module {
  func.func @test_reshape(%arg0: memref<2x3xf32>) -> memref<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %0 = bufferization.to_tensor %arg0 : memref<2x3xf32>
    %1 = bufferization.to_memref %0 : memref<2x3xf32, strided<[?, ?], offset: ?>>
    %expand_shape = memref.expand_shape %1 [[0, 1], [2]] output_shape [1, 2, 3] : memref<2x3xf32, strided<[?, ?], offset: ?>> into memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
    memref.copy %expand_shape, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
    %2 = bufferization.to_tensor %alloc : memref<1x2x3xf32>
    %3 = bufferization.to_memref %2 : memref<1x2x3xf32>
    return %3 : memref<1x2x3xf32>
  }
}


// -----// IR Dump After ConvertLinalgToAffineLoopsPass (convert-linalg-to-affine-loops) //----- //
func.func @test_reshape(%arg0: memref<2x3xf32>) -> memref<1x2x3xf32> attributes {llvm.emit_c_interface} {
  %0 = bufferization.to_tensor %arg0 : memref<2x3xf32>
  %1 = bufferization.to_memref %0 : memref<2x3xf32, strided<[?, ?], offset: ?>>
  %expand_shape = memref.expand_shape %1 [[0, 1], [2]] output_shape [1, 2, 3] : memref<2x3xf32, strided<[?, ?], offset: ?>> into memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
  memref.copy %expand_shape, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
  return %alloc : memref<1x2x3xf32>
}

// -----// IR Dump After ConvertAffineToStandard (lower-affine) //----- //
func.func @test_reshape(%arg0: memref<2x3xf32>) -> memref<1x2x3xf32> attributes {llvm.emit_c_interface} {
  %0 = bufferization.to_tensor %arg0 : memref<2x3xf32>
  %1 = bufferization.to_memref %0 : memref<2x3xf32, strided<[?, ?], offset: ?>>
  %expand_shape = memref.expand_shape %1 [[0, 1], [2]] output_shape [1, 2, 3] : memref<2x3xf32, strided<[?, ?], offset: ?>> into memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
  memref.copy %expand_shape, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
  return %alloc : memref<1x2x3xf32>
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
module {
  func.func @test_reshape(%arg0: memref<2x3xf32>) -> memref<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %0 = bufferization.to_tensor %arg0 : memref<2x3xf32>
    %1 = bufferization.to_memref %0 : memref<2x3xf32, strided<[?, ?], offset: ?>>
    %expand_shape = memref.expand_shape %1 [[0, 1], [2]] output_shape [1, 2, 3] : memref<2x3xf32, strided<[?, ?], offset: ?>> into memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
    memref.copy %expand_shape, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
    return %alloc : memref<1x2x3xf32>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
module {
  func.func @test_reshape(%arg0: memref<2x3xf32>) -> memref<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %cast = memref.cast %arg0 : memref<2x3xf32> to memref<2x3xf32, strided<[?, ?], offset: ?>>
    %expand_shape = memref.expand_shape %cast [[0, 1], [2]] output_shape [1, 2, 3] : memref<2x3xf32, strided<[?, ?], offset: ?>> into memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
    memref.copy %expand_shape, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
    return %alloc : memref<1x2x3xf32>
  }
}


// -----// IR Dump After ExpandStridedMetadata (expand-strided-metadata) //----- //
module {
  func.func @test_reshape(%arg0: memref<2x3xf32>) -> memref<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %c6 = arith.constant 6 : index
    %c0 = arith.constant 0 : index
    %c3 = arith.constant 3 : index
    %c1 = arith.constant 1 : index
    %base_buffer, %offset, %sizes:2, %strides:2 = memref.extract_strided_metadata %arg0 : memref<2x3xf32> -> memref<f32>, index, index, index, index, index
    %reinterpret_cast = memref.reinterpret_cast %base_buffer to offset: [%c0], sizes: [1, 2, 3], strides: [%c6, %c3, %c1] : memref<f32> to memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
    memref.copy %reinterpret_cast, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
    return %alloc : memref<1x2x3xf32>
  }
}


// -----// IR Dump After ConvertMathToLibm (convert-math-to-libm) //----- //
module {
  func.func @test_reshape(%arg0: memref<2x3xf32>) -> memref<1x2x3xf32> attributes {llvm.emit_c_interface} {
    %c6 = arith.constant 6 : index
    %c0 = arith.constant 0 : index
    %c3 = arith.constant 3 : index
    %c1 = arith.constant 1 : index
    %base_buffer, %offset, %sizes:2, %strides:2 = memref.extract_strided_metadata %arg0 : memref<2x3xf32> -> memref<f32>, index, index, index, index, index
    %reinterpret_cast = memref.reinterpret_cast %base_buffer to offset: [%c0], sizes: [1, 2, 3], strides: [%c6, %c3, %c1] : memref<f32> to memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
    memref.copy %reinterpret_cast, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
    return %alloc : memref<1x2x3xf32>
  }
}


// -----// IR Dump After ConvertFuncToLLVMPass (convert-func-to-llvm) //----- //
module {
  llvm.func @test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<2x3xf32>
    %9 = llvm.mlir.constant(6 : index) : i64
    %10 = builtin.unrealized_conversion_cast %9 : i64 to index
    %11 = llvm.mlir.constant(0 : index) : i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.mlir.constant(3 : index) : i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.mlir.constant(1 : index) : i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %base_buffer, %offset, %sizes:2, %strides:2 = memref.extract_strided_metadata %8 : memref<2x3xf32> -> memref<f32>, index, index, index, index, index
    %reinterpret_cast = memref.reinterpret_cast %base_buffer to offset: [%12], sizes: [1, 2, 3], strides: [%10, %14, %16] : memref<f32> to memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>>
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<1x2x3xf32>
    %17 = builtin.unrealized_conversion_cast %alloc : memref<1x2x3xf32> to !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    memref.copy %reinterpret_cast, %alloc : memref<1x2x3xf32, strided<[?, ?, ?], offset: ?>> to memref<1x2x3xf32>
    llvm.return %17 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
  }
  llvm.func @_mlir_ciface_test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.extractvalue %0[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.extractvalue %0[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = llvm.call @test_reshape(%1, %2, %3, %4, %5, %6, %7) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    llvm.store %8, %arg0 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After FinalizeMemRefToLLVMConversionPass (finalize-memref-to-llvm) //----- //
module {
  llvm.func @memrefCopy(i64, !llvm.ptr, !llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<2x3xf32>
    %9 = llvm.mlir.constant(6 : index) : i64
    %10 = builtin.unrealized_conversion_cast %9 : i64 to index
    %11 = llvm.mlir.constant(0 : index) : i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.mlir.constant(3 : index) : i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.mlir.constant(1 : index) : i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = llvm.extractvalue %7[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %18 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %19 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %20 = llvm.insertvalue %17, %19[0] : !llvm.struct<(ptr, ptr, i64)> 
    %21 = llvm.insertvalue %18, %20[1] : !llvm.struct<(ptr, ptr, i64)> 
    %22 = llvm.mlir.constant(0 : index) : i64
    %23 = llvm.insertvalue %22, %21[2] : !llvm.struct<(ptr, ptr, i64)> 
    %24 = llvm.extractvalue %7[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %25 = llvm.extractvalue %7[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %26 = llvm.extractvalue %7[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %27 = llvm.extractvalue %7[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %28 = llvm.extractvalue %7[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %29 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    %30 = llvm.extractvalue %23[0] : !llvm.struct<(ptr, ptr, i64)> 
    %31 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64)> 
    %32 = llvm.insertvalue %30, %29[0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %33 = llvm.insertvalue %31, %32[1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %34 = llvm.insertvalue %11, %33[2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %35 = llvm.mlir.constant(1 : index) : i64
    %36 = llvm.insertvalue %35, %34[3, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %37 = llvm.insertvalue %9, %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %38 = llvm.mlir.constant(2 : index) : i64
    %39 = llvm.insertvalue %38, %37[3, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %40 = llvm.insertvalue %13, %39[4, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %41 = llvm.mlir.constant(3 : index) : i64
    %42 = llvm.insertvalue %41, %40[3, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %43 = llvm.insertvalue %15, %42[4, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %44 = llvm.mlir.constant(1 : index) : i64
    %45 = llvm.mlir.constant(2 : index) : i64
    %46 = llvm.mlir.constant(3 : index) : i64
    %47 = llvm.mlir.constant(1 : index) : i64
    %48 = llvm.mlir.constant(6 : index) : i64
    %49 = llvm.mlir.constant(6 : index) : i64
    %50 = llvm.mlir.zero : !llvm.ptr
    %51 = llvm.getelementptr %50[%49] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %52 = llvm.ptrtoint %51 : !llvm.ptr to i64
    %53 = llvm.mlir.constant(64 : index) : i64
    %54 = llvm.add %52, %53 : i64
    %55 = llvm.call @malloc(%54) : (i64) -> !llvm.ptr
    %56 = llvm.ptrtoint %55 : !llvm.ptr to i64
    %57 = llvm.mlir.constant(1 : index) : i64
    %58 = llvm.sub %53, %57 : i64
    %59 = llvm.add %56, %58 : i64
    %60 = llvm.urem %59, %53  : i64
    %61 = llvm.sub %59, %60 : i64
    %62 = llvm.inttoptr %61 : i64 to !llvm.ptr
    %63 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    %64 = llvm.insertvalue %55, %63[0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %65 = llvm.insertvalue %62, %64[1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %66 = llvm.mlir.constant(0 : index) : i64
    %67 = llvm.insertvalue %66, %65[2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %68 = llvm.insertvalue %44, %67[3, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %69 = llvm.insertvalue %45, %68[3, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %70 = llvm.insertvalue %46, %69[3, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %71 = llvm.insertvalue %48, %70[4, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %72 = llvm.insertvalue %46, %71[4, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %73 = llvm.insertvalue %47, %72[4, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %74 = builtin.unrealized_conversion_cast %73 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> to memref<1x2x3xf32>
    %75 = builtin.unrealized_conversion_cast %74 : memref<1x2x3xf32> to !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    %76 = llvm.intr.stacksave : !llvm.ptr
    %77 = llvm.mlir.constant(3 : i64) : i64
    %78 = llvm.mlir.constant(1 : index) : i64
    %79 = llvm.alloca %78 x !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> : (i64) -> !llvm.ptr
    llvm.store %43, %79 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    %80 = llvm.mlir.undef : !llvm.struct<(i64, ptr)>
    %81 = llvm.insertvalue %77, %80[0] : !llvm.struct<(i64, ptr)> 
    %82 = llvm.insertvalue %79, %81[1] : !llvm.struct<(i64, ptr)> 
    %83 = llvm.mlir.constant(3 : i64) : i64
    %84 = llvm.mlir.constant(1 : index) : i64
    %85 = llvm.alloca %84 x !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> : (i64) -> !llvm.ptr
    llvm.store %73, %85 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    %86 = llvm.mlir.undef : !llvm.struct<(i64, ptr)>
    %87 = llvm.insertvalue %83, %86[0] : !llvm.struct<(i64, ptr)> 
    %88 = llvm.insertvalue %85, %87[1] : !llvm.struct<(i64, ptr)> 
    %89 = llvm.mlir.constant(1 : index) : i64
    %90 = llvm.alloca %89 x !llvm.struct<(i64, ptr)> : (i64) -> !llvm.ptr
    llvm.store %82, %90 : !llvm.struct<(i64, ptr)>, !llvm.ptr
    %91 = llvm.alloca %89 x !llvm.struct<(i64, ptr)> : (i64) -> !llvm.ptr
    llvm.store %88, %91 : !llvm.struct<(i64, ptr)>, !llvm.ptr
    %92 = llvm.mlir.zero : !llvm.ptr
    %93 = llvm.getelementptr %92[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %94 = llvm.ptrtoint %93 : !llvm.ptr to i64
    llvm.call @memrefCopy(%94, %90, %91) : (i64, !llvm.ptr, !llvm.ptr) -> ()
    llvm.intr.stackrestore %76 : !llvm.ptr
    llvm.return %75 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
  }
  llvm.func @_mlir_ciface_test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.extractvalue %0[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.extractvalue %0[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = llvm.call @test_reshape(%1, %2, %3, %4, %5, %6, %7) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    llvm.store %8, %arg0 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ReconcileUnrealizedCasts (reconcile-unrealized-casts) //----- //
module {
  llvm.func @memrefCopy(i64, !llvm.ptr, !llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = llvm.mlir.constant(6 : index) : i64
    %9 = llvm.mlir.constant(0 : index) : i64
    %10 = llvm.mlir.constant(3 : index) : i64
    %11 = llvm.mlir.constant(1 : index) : i64
    %12 = llvm.extractvalue %7[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %13 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %15 = llvm.insertvalue %12, %14[0] : !llvm.struct<(ptr, ptr, i64)> 
    %16 = llvm.insertvalue %13, %15[1] : !llvm.struct<(ptr, ptr, i64)> 
    %17 = llvm.mlir.constant(0 : index) : i64
    %18 = llvm.insertvalue %17, %16[2] : !llvm.struct<(ptr, ptr, i64)> 
    %19 = llvm.extractvalue %7[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %20 = llvm.extractvalue %7[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %21 = llvm.extractvalue %7[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %22 = llvm.extractvalue %7[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %23 = llvm.extractvalue %7[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    %25 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.insertvalue %25, %24[0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %29 = llvm.insertvalue %9, %28[2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %30 = llvm.mlir.constant(1 : index) : i64
    %31 = llvm.insertvalue %30, %29[3, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %32 = llvm.insertvalue %8, %31[4, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %33 = llvm.mlir.constant(2 : index) : i64
    %34 = llvm.insertvalue %33, %32[3, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %35 = llvm.insertvalue %10, %34[4, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %36 = llvm.mlir.constant(3 : index) : i64
    %37 = llvm.insertvalue %36, %35[3, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %38 = llvm.insertvalue %11, %37[4, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %39 = llvm.mlir.constant(1 : index) : i64
    %40 = llvm.mlir.constant(2 : index) : i64
    %41 = llvm.mlir.constant(3 : index) : i64
    %42 = llvm.mlir.constant(1 : index) : i64
    %43 = llvm.mlir.constant(6 : index) : i64
    %44 = llvm.mlir.constant(6 : index) : i64
    %45 = llvm.mlir.zero : !llvm.ptr
    %46 = llvm.getelementptr %45[%44] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %47 = llvm.ptrtoint %46 : !llvm.ptr to i64
    %48 = llvm.mlir.constant(64 : index) : i64
    %49 = llvm.add %47, %48 : i64
    %50 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.sub %48, %52 : i64
    %54 = llvm.add %51, %53 : i64
    %55 = llvm.urem %54, %48  : i64
    %56 = llvm.sub %54, %55 : i64
    %57 = llvm.inttoptr %56 : i64 to !llvm.ptr
    %58 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    %59 = llvm.insertvalue %50, %58[0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %60 = llvm.insertvalue %57, %59[1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %61 = llvm.mlir.constant(0 : index) : i64
    %62 = llvm.insertvalue %61, %60[2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %63 = llvm.insertvalue %39, %62[3, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %64 = llvm.insertvalue %40, %63[3, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %65 = llvm.insertvalue %41, %64[3, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %66 = llvm.insertvalue %43, %65[4, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %67 = llvm.insertvalue %41, %66[4, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %68 = llvm.insertvalue %42, %67[4, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %69 = llvm.intr.stacksave : !llvm.ptr
    %70 = llvm.mlir.constant(3 : i64) : i64
    %71 = llvm.mlir.constant(1 : index) : i64
    %72 = llvm.alloca %71 x !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> : (i64) -> !llvm.ptr
    llvm.store %38, %72 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    %73 = llvm.mlir.undef : !llvm.struct<(i64, ptr)>
    %74 = llvm.insertvalue %70, %73[0] : !llvm.struct<(i64, ptr)> 
    %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(i64, ptr)> 
    %76 = llvm.mlir.constant(3 : i64) : i64
    %77 = llvm.mlir.constant(1 : index) : i64
    %78 = llvm.alloca %77 x !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> : (i64) -> !llvm.ptr
    llvm.store %68, %78 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    %79 = llvm.mlir.undef : !llvm.struct<(i64, ptr)>
    %80 = llvm.insertvalue %76, %79[0] : !llvm.struct<(i64, ptr)> 
    %81 = llvm.insertvalue %78, %80[1] : !llvm.struct<(i64, ptr)> 
    %82 = llvm.mlir.constant(1 : index) : i64
    %83 = llvm.alloca %82 x !llvm.struct<(i64, ptr)> : (i64) -> !llvm.ptr
    llvm.store %75, %83 : !llvm.struct<(i64, ptr)>, !llvm.ptr
    %84 = llvm.alloca %82 x !llvm.struct<(i64, ptr)> : (i64) -> !llvm.ptr
    llvm.store %81, %84 : !llvm.struct<(i64, ptr)>, !llvm.ptr
    %85 = llvm.mlir.zero : !llvm.ptr
    %86 = llvm.getelementptr %85[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %87 = llvm.ptrtoint %86 : !llvm.ptr to i64
    llvm.call @memrefCopy(%87, %83, %84) : (i64, !llvm.ptr, !llvm.ptr) -> ()
    llvm.intr.stackrestore %69 : !llvm.ptr
    llvm.return %68 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
  }
  llvm.func @_mlir_ciface_test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.extractvalue %0[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.extractvalue %0[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = llvm.call @test_reshape(%1, %2, %3, %4, %5, %6, %7) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    llvm.store %8, %arg0 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    llvm.return
  }
}


module {
  llvm.func @memrefCopy(i64, !llvm.ptr, !llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = llvm.mlir.constant(6 : index) : i64
    %9 = llvm.mlir.constant(0 : index) : i64
    %10 = llvm.mlir.constant(3 : index) : i64
    %11 = llvm.mlir.constant(1 : index) : i64
    %12 = llvm.extractvalue %7[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %13 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %15 = llvm.insertvalue %12, %14[0] : !llvm.struct<(ptr, ptr, i64)> 
    %16 = llvm.insertvalue %13, %15[1] : !llvm.struct<(ptr, ptr, i64)> 
    %17 = llvm.mlir.constant(0 : index) : i64
    %18 = llvm.insertvalue %17, %16[2] : !llvm.struct<(ptr, ptr, i64)> 
    %19 = llvm.extractvalue %7[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %20 = llvm.extractvalue %7[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %21 = llvm.extractvalue %7[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %22 = llvm.extractvalue %7[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %23 = llvm.extractvalue %7[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    %25 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.insertvalue %25, %24[0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %28 = llvm.insertvalue %26, %27[1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %29 = llvm.insertvalue %9, %28[2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %30 = llvm.mlir.constant(1 : index) : i64
    %31 = llvm.insertvalue %30, %29[3, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %32 = llvm.insertvalue %8, %31[4, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %33 = llvm.mlir.constant(2 : index) : i64
    %34 = llvm.insertvalue %33, %32[3, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %35 = llvm.insertvalue %10, %34[4, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %36 = llvm.mlir.constant(3 : index) : i64
    %37 = llvm.insertvalue %36, %35[3, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %38 = llvm.insertvalue %11, %37[4, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %39 = llvm.mlir.constant(1 : index) : i64
    %40 = llvm.mlir.constant(2 : index) : i64
    %41 = llvm.mlir.constant(3 : index) : i64
    %42 = llvm.mlir.constant(1 : index) : i64
    %43 = llvm.mlir.constant(6 : index) : i64
    %44 = llvm.mlir.constant(6 : index) : i64
    %45 = llvm.mlir.zero : !llvm.ptr
    %46 = llvm.getelementptr %45[%44] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %47 = llvm.ptrtoint %46 : !llvm.ptr to i64
    %48 = llvm.mlir.constant(64 : index) : i64
    %49 = llvm.add %47, %48 : i64
    %50 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.sub %48, %52 : i64
    %54 = llvm.add %51, %53 : i64
    %55 = llvm.urem %54, %48  : i64
    %56 = llvm.sub %54, %55 : i64
    %57 = llvm.inttoptr %56 : i64 to !llvm.ptr
    %58 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    %59 = llvm.insertvalue %50, %58[0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %60 = llvm.insertvalue %57, %59[1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %61 = llvm.mlir.constant(0 : index) : i64
    %62 = llvm.insertvalue %61, %60[2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %63 = llvm.insertvalue %39, %62[3, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %64 = llvm.insertvalue %40, %63[3, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %65 = llvm.insertvalue %41, %64[3, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %66 = llvm.insertvalue %43, %65[4, 0] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %67 = llvm.insertvalue %41, %66[4, 1] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %68 = llvm.insertvalue %42, %67[4, 2] : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> 
    %69 = llvm.intr.stacksave : !llvm.ptr
    %70 = llvm.mlir.constant(3 : i64) : i64
    %71 = llvm.mlir.constant(1 : index) : i64
    %72 = llvm.alloca %71 x !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> : (i64) -> !llvm.ptr
    llvm.store %38, %72 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    %73 = llvm.mlir.undef : !llvm.struct<(i64, ptr)>
    %74 = llvm.insertvalue %70, %73[0] : !llvm.struct<(i64, ptr)> 
    %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(i64, ptr)> 
    %76 = llvm.mlir.constant(3 : i64) : i64
    %77 = llvm.mlir.constant(1 : index) : i64
    %78 = llvm.alloca %77 x !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)> : (i64) -> !llvm.ptr
    llvm.store %68, %78 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    %79 = llvm.mlir.undef : !llvm.struct<(i64, ptr)>
    %80 = llvm.insertvalue %76, %79[0] : !llvm.struct<(i64, ptr)> 
    %81 = llvm.insertvalue %78, %80[1] : !llvm.struct<(i64, ptr)> 
    %82 = llvm.mlir.constant(1 : index) : i64
    %83 = llvm.alloca %82 x !llvm.struct<(i64, ptr)> : (i64) -> !llvm.ptr
    llvm.store %75, %83 : !llvm.struct<(i64, ptr)>, !llvm.ptr
    %84 = llvm.alloca %82 x !llvm.struct<(i64, ptr)> : (i64) -> !llvm.ptr
    llvm.store %81, %84 : !llvm.struct<(i64, ptr)>, !llvm.ptr
    %85 = llvm.mlir.zero : !llvm.ptr
    %86 = llvm.getelementptr %85[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %87 = llvm.ptrtoint %86 : !llvm.ptr to i64
    llvm.call @memrefCopy(%87, %83, %84) : (i64, !llvm.ptr, !llvm.ptr) -> ()
    llvm.intr.stackrestore %69 : !llvm.ptr
    llvm.return %68 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
  }
  llvm.func @_mlir_ciface_test_reshape(%arg0: !llvm.ptr, %arg1: !llvm.ptr) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %5 = llvm.extractvalue %0[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %6 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %7 = llvm.extractvalue %0[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %8 = llvm.call @test_reshape(%1, %2, %3, %4, %5, %6, %7) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>
    llvm.store %8, %arg0 : !llvm.struct<(ptr, ptr, i64, array<3 x i64>, array<3 x i64>)>, !llvm.ptr
    llvm.return
  }
}
